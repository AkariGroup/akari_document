******************************
AKARIのROS2ソフト構成
******************************

AKARIのROS2でのソフト構成について詳しく説明していきます。

.. note::

   | こちらはROS2を使ったバージョンです。
   | ROSに慣れている方、使ってみたい方はこちらを推奨します。
   | ROSの使用、未使用の環境切り替え方法は :doc:`../troubleshoot/ros_switch` を参照してください。

.. note::

   新規ターミナルを起動する際に下記のターミナルの機能選択画面が表示される場合、本ページではすべて「2:ROS2」を選択します。
   2を入力し、enterを押してください。

   .. image:: ../images/terminal_function.png


=============================
AKARIのROS2ソフト構成図
=============================

| 最初に、AKARIのソフト構成図を下記に示します。
| AKARIでは、センサやディスプレイと通信するROS2アプリが自動起動するようになっています。

   .. image:: ../images/ros2_design.jpg
      :scale: 50%


=============================
ROS2版の特徴
=============================

| ROS2版とpython版の機能的な違いはありません。できることは一緒です。
| ROS2版のメリットは、各機能がノード(Node)によりモジュール化されており、ノード間の通信がしやすいことです。
| これにより、複数のROS2ノードを実行して同時にセンサデータを受信したり、両方からディスプレイに指令を出したりすることがより簡単にできます。
| また、ROSに対応したオープンソースソフトウェアは数多く公開されており、これらを組み込んでAKARIの機能開発を行う、といったこともしやすくなります。


=============================
ROS2の通信方式
=============================

構成図を見て分かる通り、AKARIでは **トピック** と **サービス** を使って通信を行っています。

| **トピック(topic)**
|  一方向のメッセージの送信/受信をする方法です。
|  送信者を **パブリッシャ(publisher)** 、受信者を **サブスクライバ (subscriber)** といいます。
|  パブリッシャはサブスクライバの状態を気にせず自分のタイミングでトピックを発信(publish)しており、そのトピックを受信(subscribe)するかはサブスクライバが決定します。
|  複数のサブスクライバが同時に受信することも可能です。

| AKARIでは、センサデータをトピックとして一定周期でpublishしています。
| アプリを作成する際には、このトピックをsubscribeすることでセンサデータを取得します。

   .. image:: ../images/ros2_topic.gif
      :scale: 30%

| **サービス(service)**
|  双方向の送信/応答をする方法です。
|  要求があった時に応答する **サーバ(server)** と、要求を行う **クライアント(client)** がいます。
|  serverはclientからサービスのリクエスト(request)があった時にのみレスポンス(response)を行い、クライアントはサーバからのレスポンスを取得できます。
|  一対一の通信です。

| AKARIでは、GPIOの制御などの指令を受け、その指令を実行するためのサービスサーバを作成しています。
| 例えばGPIOの出力を制御するアプリを作成する際には、このサービスのクライアントを作成し、サービスを呼び出す(callといいます)とAKARIはその指令を実行し、成否をクライアントに応答します。

   .. image:: ../images/ros2_service.gif
      :scale: 30%

| この2つの通信方式については、次章から詳しく説明していきます。

|
:doc:`ros2_topic` へ進む